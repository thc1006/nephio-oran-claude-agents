
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>slog-smoke: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nephio-oran-claude-agents/cmd/slog-smoke/main.go (0.0%)</option>
				
				<option value="file1">github.com/nephio-oran-claude-agents/pkg/orchestrator/orchestrator.go (88.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// slog_smoke.go - Smoke test for slog implementation  
// Run with: go run cmd/slog-smoke/main.go
package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "os"
        "strings"
        "time"

        "github.com/google/uuid"
)

func main() <span class="cov0" title="0">{
        fmt.Println("=== SLOG Smoke Test ===")
        fmt.Println()

        // Test 1: JSON Handler
        fmt.Println("Test 1: JSON Handler Output")
        fmt.Println("----------------------------")
        testJSONHandler()
        fmt.Println()

        // Test 2: Text Handler
        fmt.Println("Test 2: Text Handler Output")
        fmt.Println("----------------------------")
        testTextHandler()
        fmt.Println()

        // Test 3: Context logging
        fmt.Println("Test 3: Context Logging")
        fmt.Println("------------------------")
        testContextLogging()
        fmt.Println()

        // Test 4: Structured attributes
        fmt.Println("Test 4: Structured Attributes")
        fmt.Println("------------------------------")
        testStructuredAttributes()
        fmt.Println()

        // Test 5: Log levels
        fmt.Println("Test 5: Log Levels")
        fmt.Println("------------------")
        testLogLevels()
        fmt.Println()

        // Test 6: Verify JSON keys
        fmt.Println("Test 6: Verify JSON Keys")
        fmt.Println("------------------------")
        if verifyJSONKeys() </span><span class="cov0" title="0">{
                fmt.Println("✅ JSON keys verification PASSED")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("❌ JSON keys verification FAILED")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println()

        fmt.Println("=== All smoke tests completed successfully ===")</span>
}

func testJSONHandler() <span class="cov0" title="0">{
        // Create JSON handler
        opts := &amp;slog.HandlerOptions{
                Level:     slog.LevelDebug,
                AddSource: true,
        }
        handler := slog.NewJSONHandler(os.Stdout, opts)
        logger := slog.New(handler)

        // Log various levels
        logger.Debug("Debug message", slog.String("handler", "json"))
        logger.Info("Info message", slog.String("handler", "json"))
        logger.Warn("Warning message", slog.String("handler", "json"))
        logger.Error("Error message", slog.String("handler", "json"))
}</span>

func testTextHandler() <span class="cov0" title="0">{
        // Create Text handler
        opts := &amp;slog.HandlerOptions{
                Level:     slog.LevelInfo,
                AddSource: false,
        }
        handler := slog.NewTextHandler(os.Stdout, opts)
        logger := slog.New(handler)

        // Log with text handler
        logger.Info("Info with text handler",
                slog.String("format", "text"),
                slog.Int("count", 42))
        logger.Warn("Warning with text handler",
                slog.Duration("elapsed", 1500*time.Millisecond))
}</span>

func testContextLogging() <span class="cov0" title="0">{
        // Setup logger
        handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        })
        logger := slog.New(handler)

        // Create context with values
        ctx := context.Background()
        ctx = context.WithValue(ctx, "correlation_id", uuid.New().String())
        ctx = context.WithValue(ctx, "user_id", "user-123")
        ctx = context.WithValue(ctx, "request_id", "req-456")

        // Extract values and log with context
        correlationID, _ := ctx.Value("correlation_id").(string)
        userID, _ := ctx.Value("user_id").(string)
        requestID, _ := ctx.Value("request_id").(string)

        // Log with context
        logger.InfoContext(ctx, "Processing request",
                slog.String("correlation_id", correlationID),
                slog.String("user_id", userID),
                slog.String("request_id", requestID),
                slog.String("operation", "test_context"))

        // Simulate operation with timing
        start := time.Now()
        time.Sleep(100 * time.Millisecond)
        
        logger.InfoContext(ctx, "Request completed",
                slog.String("correlation_id", correlationID),
                slog.Duration("duration", time.Since(start)),
                slog.String("status", "success"))
}</span>

func testStructuredAttributes() <span class="cov0" title="0">{
        handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        })
        logger := slog.New(handler)

        // Create logger with common attributes
        serviceLogger := logger.With(
                slog.String("service", "nephio-orchestrator"),
                slog.String("version", "r5.0.1"),
                slog.String("environment", "production"),
        )

        // Log with service context
        serviceLogger.Info("Service started",
                slog.Int("port", 8080),
                slog.String("host", "0.0.0.0"))

        // Nested groups
        serviceLogger.Info("Metrics collected",
                slog.Group("metrics",
                        slog.Int("requests", 1000),
                        slog.Float64("latency_ms", 25.5),
                        slog.Int("errors", 3),
                ),
                slog.Group("resources",
                        slog.Float64("cpu_percent", 45.2),
                        slog.Float64("memory_mb", 512.7),
                ))

        // Array of values
        serviceLogger.Info("Batch processed",
                slog.Any("items", []string{"item1", "item2", "item3"}),
                slog.Int("batch_size", 3))
}</span>

func testLogLevels() <span class="cov0" title="0">{
        // Test different log levels
        levels := []slog.Level{
                slog.LevelDebug,
                slog.LevelInfo,
                slog.LevelWarn,
                slog.LevelError,
        }

        for _, level := range levels </span><span class="cov0" title="0">{
                handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level: level,
                })
                logger := slog.New(handler)

                // This will only show if level is Debug or lower
                logger.Debug("Debug level test", slog.String("level", level.String()))
                
                // This will show for Info and lower
                logger.Info("Info level test", slog.String("level", level.String()))
                
                // This will show for Warn and lower
                logger.Warn("Warn level test", slog.String("level", level.String()))
                
                // This will always show
                logger.Error("Error level test", slog.String("level", level.String()))
        }</span>
}

func verifyJSONKeys() bool <span class="cov0" title="0">{
        // Create a custom writer to capture output
        var buf strings.Builder
        handler := slog.NewJSONHandler(&amp;buf, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        })
        logger := slog.New(handler)

        // Log a test message
        ctx := context.Background()
        logger.InfoContext(ctx, "Test message",
                slog.String("key1", "value1"),
                slog.Int("key2", 42),
                slog.Time("timestamp", time.Now()),
                slog.Duration("duration", 100*time.Millisecond),
                slog.Bool("flag", true),
        )

        // Parse the JSON output
        var result map[string]interface{}
        output := buf.String()
        if err := json.Unmarshal([]byte(output), &amp;result); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to parse JSON: %v\n", err)
                fmt.Printf("Output was: %s\n", output)
                return false
        }</span>

        // Verify expected keys exist
        <span class="cov0" title="0">requiredKeys := []string{"time", "level", "msg", "key1", "key2", "timestamp", "duration", "flag"}
        missingKeys := []string{}
        
        for _, key := range requiredKeys </span><span class="cov0" title="0">{
                if _, exists := result[key]; !exists </span><span class="cov0" title="0">{
                        missingKeys = append(missingKeys, key)
                }</span>
        }

        <span class="cov0" title="0">if len(missingKeys) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Missing required keys: %v\n", missingKeys)
                return false
        }</span>

        // Verify values
        <span class="cov0" title="0">if result["key1"] != "value1" </span><span class="cov0" title="0">{
                fmt.Printf("Expected key1='value1', got %v\n", result["key1"])
                return false
        }</span>

        // JSON numbers are float64 by default
        <span class="cov0" title="0">if int(result["key2"].(float64)) != 42 </span><span class="cov0" title="0">{
                fmt.Printf("Expected key2=42, got %v\n", result["key2"])
                return false
        }</span>

        <span class="cov0" title="0">if result["flag"] != true </span><span class="cov0" title="0">{
                fmt.Printf("Expected flag=true, got %v\n", result["flag"])
                return false
        }</span>

        <span class="cov0" title="0">fmt.Printf("JSON output verified successfully\n")
        fmt.Printf("Sample output: %s", output)
        return true</span>
}

// TestError demonstrates error logging patterns
func testErrorLogging() <span class="cov0" title="0">{
        handler := slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        })
        logger := slog.New(handler)

        // Simulate an error with context
        err := fmt.Errorf("database connection failed: timeout after 30s")
        
        logger.Error("Operation failed",
                slog.String("operation", "database_connect"),
                slog.String("error", err.Error()),
                slog.String("severity", "critical"),
                slog.Bool("retryable", true),
                slog.Int("retry_count", 3),
                slog.Duration("retry_after", 5*time.Second),
        )
}</pre>
		
		<pre class="file" id="file1" style="display: none">// Package orchestrator implements modernized Go 1.24.6 patterns for Nephio R5/O-RAN L Release
package orchestrator

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "os"
        "slices"
        "sync"
        "time"

        "github.com/cenkalti/backoff/v4"
        "github.com/google/uuid"
)

// Package-level logger configured once
var logger *slog.Logger

func init() <span class="cov1" title="1">{
        // Initialize package-level logger with JSON handler
        opts := &amp;slog.HandlerOptions{
                Level:     slog.LevelInfo,
                AddSource: true,
        }
        
        // Use JSON handler for production, Text for development
        if os.Getenv("LOG_FORMAT") == "text" </span><span class="cov0" title="0">{
                handler := slog.NewTextHandler(os.Stdout, opts)
                logger = slog.New(handler)
        }</span> else<span class="cov1" title="1"> {
                handler := slog.NewJSONHandler(os.Stdout, opts)
                logger = slog.New(handler)
        }</span>
}

// ErrorSeverity represents the severity of an error
type ErrorSeverity int

const (
        SeverityInfo ErrorSeverity = iota
        SeverityWarning
        SeverityError
        SeverityCritical
)

// OrchestratorError provides structured error handling
type OrchestratorError struct {
        Code          string        `json:"code"`
        Message       string        `json:"message"`
        Component     string        `json:"component"`
        CorrelationID string        `json:"correlation_id"`
        Severity      ErrorSeverity `json:"severity"`
        Timestamp     time.Time     `json:"timestamp"`
        Err           error         `json:"-"`
        Retryable     bool          `json:"retryable"`
}

func (e *OrchestratorError) Error() string <span class="cov2" title="4">{
        if e.Err != nil </span><span class="cov2" title="3">{
                return fmt.Sprintf("[%s] %s: %s (correlation: %s) - %v",
                        e.Code, e.Component, e.Message, e.CorrelationID, e.Err)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("[%s] %s: %s (correlation: %s)",
                e.Code, e.Component, e.Message, e.CorrelationID)</span>
}

func (e *OrchestratorError) Unwrap() error <span class="cov1" title="2">{
        return e.Err
}</span>

// Orchestrator manages network function orchestration
type Orchestrator struct {
        correlationID string
        httpClient    *http.Client
        mu            sync.RWMutex
}

// NewOrchestrator creates a new orchestrator with context
func NewOrchestrator(ctx context.Context) *Orchestrator <span class="cov3" title="22">{
        // Extract or generate correlation ID
        correlationID, ok := ctx.Value("correlation_id").(string)
        if !ok || correlationID == "" </span><span class="cov3" title="21">{
                correlationID = uuid.New().String()
        }</span>

        // Create HTTP client with timeout
        <span class="cov3" title="22">httpClient := &amp;http.Client{
                Timeout: 30 * time.Second,
                Transport: &amp;http.Transport{
                        MaxIdleConns:        100,
                        MaxIdleConnsPerHost: 10,
                        IdleConnTimeout:     90 * time.Second,
                },
        }

        return &amp;Orchestrator{
                correlationID: correlationID,
                httpClient:    httpClient,
        }</span>
}

// ProcessWithRetry demonstrates modern retry with exponential backoff
func (o *Orchestrator) ProcessWithRetry(ctx context.Context, data []string) error <span class="cov2" title="6">{
        // Add timeout to context
        ctx, cancel := context.WithTimeout(ctx, 2*time.Minute)
        defer cancel()

        // Log with context and correlation ID
        logger.InfoContext(ctx, "Starting processing with retry",
                slog.String("correlation_id", o.correlationID),
                slog.Int("data_count", len(data)),
                slog.String("operation", "process_with_retry"))

        // Configure exponential backoff
        expBackoff := backoff.NewExponentialBackOff()
        expBackoff.InitialInterval = 500 * time.Millisecond
        expBackoff.MaxInterval = 10 * time.Second
        expBackoff.MaxElapsedTime = 1 * time.Minute
        expBackoff.Multiplier = 2.0
        expBackoff.RandomizationFactor = 0.1

        // Wrap operation with backoff
        operation := func() error </span><span class="cov2" title="6">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        logger.WarnContext(ctx, "Context cancelled during retry",
                                slog.String("correlation_id", o.correlationID))
                        return backoff.Permanent(ctx.Err())</span>
                default:<span class="cov2" title="6"></span>
                }

                // Actual processing logic
                <span class="cov2" title="6">if err := o.process(ctx, data); err != nil </span><span class="cov1" title="2">{
                        // Determine if error is retryable
                        var orchErr *OrchestratorError
                        if errors.As(err, &amp;orchErr) &amp;&amp; !orchErr.Retryable </span><span class="cov0" title="0">{
                                logger.ErrorContext(ctx, "Non-retryable error encountered",
                                        slog.String("correlation_id", o.correlationID),
                                        slog.String("error_code", orchErr.Code))
                                return backoff.Permanent(err)
                        }</span>

                        <span class="cov1" title="2">logger.WarnContext(ctx, "Retryable error, will retry",
                                slog.String("correlation_id", o.correlationID),
                                slog.String("error", err.Error()))
                        return err</span>
                }
                <span class="cov2" title="4">return nil</span>
        }

        // Execute with retry
        <span class="cov2" title="6">if err := backoff.Retry(operation, backoff.WithContext(expBackoff, ctx)); err != nil </span><span class="cov1" title="2">{
                logger.ErrorContext(ctx, "Processing failed after retries",
                        slog.String("correlation_id", o.correlationID),
                        slog.String("error", err.Error()))
                return &amp;OrchestratorError{
                        Code:          "PROCESS_FAILED",
                        Message:       "Failed to process data after retries",
                        Component:     "Orchestrator",
                        CorrelationID: o.correlationID,
                        Severity:      SeverityCritical,
                        Timestamp:     time.Now(),
                        Err:           err,
                        Retryable:     false,
                }
        }</span>

        <span class="cov2" title="4">logger.InfoContext(ctx, "Processing completed successfully",
                slog.String("correlation_id", o.correlationID))
        return nil</span>
}

// process simulates internal processing
func (o *Orchestrator) process(ctx context.Context, data []string) error <span class="cov2" title="6">{
        // Simulate processing with context check
        for i, item := range data </span><span class="cov4" title="58">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="2">
                        return ctx.Err()</span>
                default:<span class="cov4" title="56">
                        logger.DebugContext(ctx, "Processing item",
                                slog.String("correlation_id", o.correlationID),
                                slog.Int("index", i),
                                slog.String("item", item))
                        // Simulate work
                        time.Sleep(10 * time.Millisecond)</span>
                }
        }
        <span class="cov2" title="4">return nil</span>
}

// ProcessBatchesWithIterator demonstrates modern iterator pattern for batch processing
func (o *Orchestrator) ProcessBatchesWithIterator(ctx context.Context, items []string, batchSize int) error <span class="cov2" title="5">{
        // Add timeout for entire batch processing
        ctx, cancel := context.WithTimeout(ctx, 5*time.Minute)
        defer cancel()

        logger.InfoContext(ctx, "Starting batch processing with iterator",
                slog.String("correlation_id", o.correlationID),
                slog.Int("total_items", len(items)),
                slog.Int("batch_size", batchSize))

        // Use slices.Chunk for clean iteration (Go 1.23+)
        // For Go 1.24.6, we'll implement a compatible version
        batchNum := 0
        for batch := range ChunkSlice(items, batchSize) </span><span class="cov5" title="124">{
                batchNum++
                
                // Create batch-specific context with timeout
                batchCtx, batchCancel := context.WithTimeout(ctx, 30*time.Second)
                
                logger.DebugContext(batchCtx, "Processing batch",
                        slog.String("correlation_id", o.correlationID),
                        slog.Int("batch_num", batchNum),
                        slog.Int("batch_size", len(batch)))

                // Process batch with retry
                err := o.processBatchWithBackoff(batchCtx, batch, batchNum)
                batchCancel()
                
                if err != nil </span><span class="cov1" title="1">{
                        logger.ErrorContext(ctx, "Batch processing failed",
                                slog.String("correlation_id", o.correlationID),
                                slog.Int("batch_num", batchNum),
                                slog.String("error", err.Error()))
                        return err
                }</span>
        }

        <span class="cov2" title="4">logger.InfoContext(ctx, "All batches processed successfully",
                slog.String("correlation_id", o.correlationID),
                slog.Int("total_batches", batchNum))
        return nil</span>
}

// ChunkSlice implements iterator pattern for batch processing
// Compatible with Go 1.24.6 (slices.Chunk may not be available)
func ChunkSlice[T any](slice []T, size int) &lt;-chan []T <span class="cov3" title="10">{
        ch := make(chan []T)
        go func() </span><span class="cov3" title="10">{
                defer close(ch)
                for i := 0; i &lt; len(slice); i += size </span><span class="cov5" title="144">{
                        end := i + size
                        if end &gt; len(slice) </span><span class="cov2" title="3">{
                                end = len(slice)
                        }</span>
                        <span class="cov5" title="144">ch &lt;- slice[i:end]</span>
                }
        }()
        <span class="cov3" title="10">return ch</span>
}

// processBatchWithBackoff processes a batch with retry logic
func (o *Orchestrator) processBatchWithBackoff(ctx context.Context, batch []string, batchNum int) error <span class="cov5" title="124">{
        b := backoff.NewExponentialBackOff()
        b.MaxElapsedTime = 20 * time.Second
        b.InitialInterval = 100 * time.Millisecond

        operation := func() error </span><span class="cov5" title="124">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return backoff.Permanent(ctx.Err())</span>
                default:<span class="cov5" title="124">
                        // Simulate batch processing
                        for _, item := range batch </span><span class="cov9" title="11009">{
                                if err := o.processItem(ctx, item); err != nil </span><span class="cov1" title="1">{
                                        return err
                                }</span>
                        }
                        <span class="cov5" title="123">return nil</span>
                }
        }

        <span class="cov5" title="124">return backoff.Retry(operation, backoff.WithContext(b, ctx))</span>
}

// processItem processes a single item
func (o *Orchestrator) processItem(ctx context.Context, item string) error <span class="cov10" title="11014">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return ctx.Err()</span>
        default:<span class="cov9" title="11013">
                // Simulate processing
                time.Sleep(5 * time.Millisecond)
                return nil</span>
        }
}

// MakeHTTPRequest demonstrates HTTP call with proper timeout and context
func (o *Orchestrator) MakeHTTPRequest(ctx context.Context, url string) (*http.Response, error) <span class="cov2" title="3">{
        // Create request-specific timeout
        reqCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        logger.InfoContext(reqCtx, "Making HTTP request",
                slog.String("correlation_id", o.correlationID),
                slog.String("url", url))

        // Create request with context
        req, err := http.NewRequestWithContext(reqCtx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.ErrorContext(reqCtx, "Failed to create request",
                        slog.String("correlation_id", o.correlationID),
                        slog.String("error", err.Error()))
                return nil, err
        }</span>

        // Add correlation ID to headers
        <span class="cov2" title="3">req.Header.Set("X-Correlation-ID", o.correlationID)

        // Execute request with configured client
        resp, err := o.httpClient.Do(req)
        if err != nil </span><span class="cov2" title="3">{
                logger.ErrorContext(reqCtx, "HTTP request failed",
                        slog.String("correlation_id", o.correlationID),
                        slog.String("url", url),
                        slog.String("error", err.Error()))
                return nil, err
        }</span>

        <span class="cov0" title="0">logger.InfoContext(reqCtx, "HTTP request completed",
                slog.String("correlation_id", o.correlationID),
                slog.Int("status_code", resp.StatusCode))

        return resp, nil</span>
}

// ProcessConcurrently demonstrates concurrent processing with proper context
func (o *Orchestrator) ProcessConcurrently(ctx context.Context, items []string, workers int) error <span class="cov3" title="17">{
        ctx, cancel := context.WithTimeout(ctx, 3*time.Minute)
        defer cancel()

        logger.InfoContext(ctx, "Starting concurrent processing",
                slog.String("correlation_id", o.correlationID),
                slog.Int("items", len(items)),
                slog.Int("workers", workers))

        // Create channels
        itemChan := make(chan string, len(items))
        errChan := make(chan error, 1)
        var wg sync.WaitGroup

        // Add items to channel
        for _, item := range items </span><span class="cov7" title="710">{
                itemChan &lt;- item
        }</span>
        <span class="cov3" title="17">close(itemChan)

        // Start workers
        for i := 0; i &lt; workers; i++ </span><span class="cov4" title="57">{
                wg.Add(1)
                go func(workerID int) </span><span class="cov4" title="57">{
                        defer wg.Done()
                        
                        for item := range itemChan </span><span class="cov7" title="613">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        select </span>{
                                        case errChan &lt;- ctx.Err():<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                default:<span class="cov7" title="613">
                                        if err := o.processWithTimeout(ctx, item, workerID); err != nil </span><span class="cov2" title="5">{
                                                logger.ErrorContext(ctx, "Worker processing failed",
                                                        slog.String("correlation_id", o.correlationID),
                                                        slog.Int("worker_id", workerID),
                                                        slog.String("item", item),
                                                        slog.String("error", err.Error()))
                                                select </span>{
                                                case errChan &lt;- err:<span class="cov1" title="1"></span>
                                                default:<span class="cov2" title="4"></span>
                                                }
                                                <span class="cov2" title="5">return</span>
                                        }
                                }
                        }
                }(i)
        }

        // Wait for completion or error
        <span class="cov3" title="17">done := make(chan struct{})
        go func() </span><span class="cov3" title="17">{
                wg.Wait()
                close(done)
        }</span>()

        <span class="cov3" title="17">select </span>{
        case &lt;-done:<span class="cov3" title="16">
                logger.InfoContext(ctx, "Concurrent processing completed",
                        slog.String("correlation_id", o.correlationID))
                return nil</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                cancel() // Cancel context to stop other workers
                return err</span>
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return ctx.Err()</span>
        }
}

// processWithTimeout processes an item with its own timeout
func (o *Orchestrator) processWithTimeout(ctx context.Context, item string, workerID int) error <span class="cov7" title="613">{
        // Item-specific timeout
        itemCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        logger.DebugContext(itemCtx, "Worker processing item",
                slog.String("correlation_id", o.correlationID),
                slog.Int("worker_id", workerID),
                slog.String("item", item))

        // Simulate processing
        select </span>{
        case &lt;-time.After(100 * time.Millisecond):<span class="cov7" title="608">
                return nil</span>
        case &lt;-itemCtx.Done():<span class="cov2" title="5">
                return itemCtx.Err()</span>
        }
}

// ProcessWithIteratorV2 demonstrates using range over func (Go 1.23+)
func (o *Orchestrator) ProcessWithIteratorV2(ctx context.Context, items []string) error <span class="cov1" title="1">{
        ctx, cancel := context.WithTimeout(ctx, 2*time.Minute)
        defer cancel()

        logger.InfoContext(ctx, "Processing with iterator v2",
                slog.String("correlation_id", o.correlationID),
                slog.Int("items", len(items)))

        // Process items using iterator
        for i, item := range slices.All(items) </span><span class="cov2" title="5">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov2" title="5">
                        logger.DebugContext(ctx, "Processing item",
                                slog.String("correlation_id", o.correlationID),
                                slog.Int("index", i),
                                slog.String("item", item))
                        
                        if err := o.processItem(ctx, item); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
