"use strict";(self.webpackChunknephio_oran_claude_agents_website=self.webpackChunknephio_oran_claude_agents_website||[]).push([[7627],{1584:(r,e,n)=>{n(6540);n(4848)},5263:(r,e,n)=>{n.d(e,{GL:()=>h,hK:()=>u,xt:()=>d,a5:()=>l,Ay:()=>c});n(6540);var t=n(4164),i=n(8589);const o={releaseBadge:"releaseBadge_Id0R",default:"default__v4Q",outline:"outline_Zskd",minimal:"minimal_mrID",small:"small_VbES",icon:"icon_Fvah",medium:"medium_VxeN",large:"large_b9I_",content:"content_vUIE",label:"label_P4Dt",version:"version_wXDD",withIcon:"withIcon_JRTn",pulse:"pulse_gZVh"};var s=n(4848);const a={oran:{label:"O-RAN",color:"primary",icon:"\ud83d\udce1",defaultVersion:i.GZ.ORAN},nephio:{label:"Nephio",color:"success",icon:"\u2638\ufe0f",defaultVersion:i.GZ.NEPHIO},go:{label:"Go",color:"info",icon:"\ud83d\udc39",defaultVersion:i.GZ.GO},kpt:{label:"kpt",color:"warning",icon:"\ud83d\udce6",defaultVersion:i.GZ.KPT},kubernetes:{label:"Kubernetes",color:"secondary",icon:"\u2638\ufe0f",defaultVersion:i.GZ.KUBERNETES}};function c({type:r,version:e,variant:n="default",size:i="medium",showIcon:c=!0,className:l}){const d=a[r],h=e||d.defaultVersion,u=(0,t.A)("badge",`badge--${d.color}`,o.releaseBadge,o[n],o[i],{[o.withIcon]:c},l);return(0,s.jsxs)("span",{className:u,title:`${d.label} ${h}`,children:[c&&(0,s.jsx)("span",{className:o.icon,role:"img","aria-label":d.label,children:d.icon}),(0,s.jsxs)("span",{className:o.content,children:[(0,s.jsx)("span",{className:o.label,children:d.label}),(0,s.jsx)("span",{className:o.version,children:h})]})]})}function l(r){return(0,s.jsx)(c,{type:"oran",...r})}function d(r){return(0,s.jsx)(c,{type:"nephio",...r})}function h(r){return(0,s.jsx)(c,{type:"go",...r})}function u(r){return(0,s.jsx)(c,{type:"kpt",...r})}},7263:(r,e,n)=>{n.d(e,{A:()=>c});n(6540);var t=n(4164),i=n(8589),o=n(5263);const s={supportStatement:"supportStatement_S2kY",header:"header_l9lJ",title:"title_AeZn",lastUpdated:"lastUpdated_MoFp",description:"description_KXpn",versionList:"versionList_cqg2",versionItem:"versionItem_syod",versionDescription:"versionDescription_jPtX",additionalInfo:"additionalInfo_WK88",note:"note_vUZr",policy:"policy_cPDb",compact:"compact_qOpz",badgesOnly:"badgesOnly_ST1i",badges:"badges_Fidq"};var a=n(4848);function c({variant:r="full",showLastUpdated:e=!0,className:n}){const c=(0,t.A)(s.supportStatement,s[r],n);return"badges-only"===r?(0,a.jsx)("div",{className:c,children:(0,a.jsxs)("div",{className:s.badges,children:[(0,a.jsx)(o.Ay,{type:"go",size:"small"}),(0,a.jsx)(o.Ay,{type:"oran",size:"small"}),(0,a.jsx)(o.Ay,{type:"nephio",size:"small"}),(0,a.jsx)(o.Ay,{type:"kpt",size:"small"})]})}):(0,a.jsxs)("div",{className:c,children:[(0,a.jsxs)("div",{className:s.header,children:[(0,a.jsx)("h4",{className:s.title,children:"compact"===r?"Supported Versions":"Version Support Statement"}),e&&(0,a.jsxs)("span",{className:s.lastUpdated,children:["Updated: ",i.TF]})]}),(0,a.jsxs)("div",{className:s.content,children:["full"===r&&(0,a.jsx)("p",{className:s.description,children:"This documentation and the associated Claude agents are tested and supported with the following canonical versions of O-RAN, Nephio, and related technologies."}),(0,a.jsxs)("div",{className:s.versionList,children:[(0,a.jsxs)("div",{className:s.versionItem,children:[(0,a.jsx)(o.Ay,{type:"go",variant:"outline",size:"medium"}),(0,a.jsx)("span",{className:s.versionDescription,children:"Required Go runtime version for agent execution"})]}),(0,a.jsxs)("div",{className:s.versionItem,children:[(0,a.jsx)(o.Ay,{type:"oran",variant:"outline",size:"medium"}),(0,a.jsx)("span",{className:s.versionDescription,children:"O-RAN Alliance L-Release specifications and implementations"})]}),(0,a.jsxs)("div",{className:s.versionItem,children:[(0,a.jsx)(o.Ay,{type:"nephio",variant:"outline",size:"medium"}),(0,a.jsx)("span",{className:s.versionDescription,children:"Nephio R5 package orchestration and GitOps workflows"})]}),(0,a.jsxs)("div",{className:s.versionItem,children:[(0,a.jsx)(o.Ay,{type:"kpt",variant:"outline",size:"medium"}),(0,a.jsx)("span",{className:s.versionDescription,children:"Configuration as Data package management with kpt"})]})]}),"full"===r&&(0,a.jsxs)("div",{className:s.additionalInfo,children:[(0,a.jsxs)("div",{className:s.note,children:[(0,a.jsx)("strong",{children:"Note:"})," While these are the canonical supported versions, many agents may work with adjacent versions. Please refer to individual agent documentation for specific compatibility requirements."]}),(0,a.jsxs)("div",{className:s.policy,children:[(0,a.jsx)("strong",{children:"Support Policy:"})," We follow Kubernetes' support policy of maintaining compatibility with the latest three minor releases."]})]})]})]})}},7630:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"agents/orchestrator/nephio-oran-orchestrator","title":"Core Nephio CRDs","description":"nephio-oran-orchestrator-agent","source":"@site/docs/agents/orchestrator/nephio-oran-orchestrator-agent.mdx","sourceDirName":"agents/orchestrator","slug":"/agents/orchestrator/nephio-oran-orchestrator","permalink":"/nephio-oran-claude-agents/docs/agents/orchestrator/nephio-oran-orchestrator","draft":false,"unlisted":false,"editUrl":"https://github.com/thc1006/nephio-oran-claude-agents/tree/main/website/docs/agents/orchestrator/nephio-oran-orchestrator-agent.mdx","tags":[{"inline":true,"label":"claude-agent","permalink":"/nephio-oran-claude-agents/docs/tags/claude-agent"},{"inline":true,"label":"nephio","permalink":"/nephio-oran-claude-agents/docs/tags/nephio"},{"inline":true,"label":"o-ran","permalink":"/nephio-oran-claude-agents/docs/tags/o-ran"},{"inline":true,"label":"orchestrator","permalink":"/nephio-oran-claude-agents/docs/tags/orchestrator"}],"version":"current","lastUpdatedBy":"thc1006","lastUpdatedAt":1755722502000,"sidebarPosition":1,"frontMatter":{"id":"nephio-oran-orchestrator","title":"Core Nephio CRDs","description":"nephio-oran-orchestrator-agent","sidebar_label":"Core Nephio CRDs","sidebar_position":1,"tags":["claude-agent","nephio","o-ran","orchestrator"],"keywords":["nephio","o-ran","cloud-native","kubernetes","orchestrator","core","crds"]}}');var i=n(4848),o=n(8453),s=(n(1584),n(5263));n(7263);const a={id:"nephio-oran-orchestrator",title:"Core Nephio CRDs",description:"nephio-oran-orchestrator-agent",sidebar_label:"Core Nephio CRDs",sidebar_position:1,tags:["claude-agent","nephio","o-ran","orchestrator"],keywords:["nephio","o-ran","cloud-native","kubernetes","orchestrator","core","crds"]},c=void 0,l={},d=[{value:"Nephio R5 Expertise",id:"nephio-r5-expertise",level:2},{value:"Core Nephio R5 Features",id:"core-nephio-r5-features",level:3},{value:"Kpt and Package Management",id:"kpt-and-package-management",level:3},{value:"Critical CRDs and Operators",id:"critical-crds-and-operators",level:3},{value:"O-RAN L (released 2025-06-30) Integration",id:"o-ran-l-released-2025-06-30-integration",level:2},{value:"Latest O-RAN L (released 2025-06-30) Specifications (O-RAN SC L Release - 2025-06-30)",id:"latest-o-ran-l-released-2025-06-30-specifications-o-ran-sc-l-release---2025-06-30",level:3},{value:"Interface Orchestration",id:"interface-orchestration",level:3},{value:"Orchestration Patterns",id:"orchestration-patterns",level:2},{value:"Intent-Based Automation",id:"intent-based-automation",level:3},{value:"Multi-Cluster Coordination",id:"multi-cluster-coordination",level:3},{value:"Subagent Coordination Protocol",id:"subagent-coordination-protocol",level:2},{value:"Agent Communication",id:"agent-communication",level:3},{value:"Workflow Orchestration",id:"workflow-orchestration",level:3},{value:"Advanced Capabilities",id:"advanced-capabilities",level:2},{value:"AI/ML Integration",id:"aiml-integration",level:3},{value:"GitOps Workflows (R5 Primary: ArgoCD)",id:"gitops-workflows-r5-primary-argocd",level:3},{value:"Error Recovery Strategies",id:"error-recovery-strategies",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Resource Management",id:"resource-management",level:3},{value:"Monitoring and Observability",id:"monitoring-and-observability",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Go Development Integration",id:"go-development-integration",level:2},{value:"Current Version Compatibility Matrix (August 2025)",id:"current-version-compatibility-matrix-august-2025",level:2},{value:"Core Dependencies - Tested and Supported",id:"core-dependencies---tested-and-supported",level:3}];function h(r){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...r.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)("div",{className:"badges-container",children:[(0,i.jsx)(s.a5,{}),(0,i.jsx)(s.xt,{}),(0,i.jsx)(s.GL,{}),(0,i.jsx)(s.hK,{})]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsxs)(e.p,{children:['name: nephio-oran-orchestrator-agent\r\ndescription: Use PROACTIVELY for Nephio R5 and O-RAN L (released 2025-06-30) orchestration, Kpt function chains, Package Variant management, and cross-domain intelligent automation. MUST BE USED for complex integration workflows, policy orchestration, and multi-cluster deployments.\r\nmodel: opus\r\ntools: Read, Write, Bash, Search, Git\r\nversion: 2.1.0\r\nlast_updated: 2025-08-20\r\ndependencies:\r\ngo: 1.24.6\r\nkubernetes: 1.30+\r\nargocd: 3.1.0+\r\nkpt: v1.0.0-beta.55\r\nhelm: 3.14+\r\nnephio: r5\r\nporch: 1.0.0+\r\ncluster-api: 1.6.0+\r\nmetal3: 1.6.0+\r\ncrossplane: 1.15.0+\r\nflux: 2.2+\r\nterraform: 1.7+\r\nansible: 9.2+\r\nkubeflow: 1.8+\r\npython: 3.11+\r\nyang-tools: 2.6.1+\r\nkustomize: 5.0+\r\nkubectl: 1.30.0-1.34.0  # Kubernetes 1.30+ compatible versions\r\ncompatibility:\r\nnephio: r5\r\noran: l-release\r\ngo: 1.24.6\r\nkubernetes: 1.30+\r\nargocd: 3.1.0+\r\nprometheus: 2.48+\r\ngrafana: 10.3+\r\nvalidation_status: tested\r\nmaintainer:\r\nname: "Nephio R5/O-RAN L (released 2025-06-30) Team"\r\nemail: "',(0,i.jsx)(e.a,{href:"mailto:nephio-oran@example.com",children:"nephio-oran@example.com"}),'"\r\norganization: "O-RAN Software Community"\r\nrepository: "',(0,i.jsx)(e.a,{href:"https://github.com/nephio-project/nephio",children:"https://github.com/nephio-project/nephio"}),'"\r\nnotes:']}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:['"Consolidated orchestrator documentation on 2025-08-20 - merged oran-nephio-orchestrator-agent.md into this file"\r\nstandards:\r\nnephio:',"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:'"Nephio R5 Architecture Specification v2.0"'}),"\n",(0,i.jsx)(e.li,{children:'"Nephio Package Specialization v1.2"'}),"\n",(0,i.jsx)(e.li,{children:'"Nephio GitOps Workflow Specification v1.1"'}),"\n",(0,i.jsx)(e.li,{children:'"Nephio Multi-cluster Orchestration v1.0"\r\noran:'}),"\n",(0,i.jsx)(e.li,{children:'"O-RAN.WG1.O1-Interface.0-v16.00"'}),"\n",(0,i.jsx)(e.li,{children:'"O-RAN.WG4.MP.0-R004-v16.01"'}),"\n",(0,i.jsx)(e.li,{children:'"O-RAN.WG6.O2-Interface-v3.0"'}),"\n",(0,i.jsx)(e.li,{children:'"O-RAN L (released 2025-06-30) Architecture v1.0"'}),"\n",(0,i.jsx)(e.li,{children:'"O-RAN AI/ML Framework Specification v2.0"'}),"\n",(0,i.jsx)(e.li,{children:'"O-RAN Service Manager Specification v2.0"\r\nkubernetes:'}),"\n",(0,i.jsx)(e.li,{children:'"Kubernetes API Specification v1.30+"'}),"\n",(0,i.jsx)(e.li,{children:'"Custom Resource Definition v1.30+"'}),"\n",(0,i.jsx)(e.li,{children:'"ArgoCD Application API v2.12+"'}),"\n",(0,i.jsx)(e.li,{children:'"Cluster API Specification v1.6+"\r\ngo:'}),"\n",(0,i.jsx)(e.li,{children:'"Go Language Specification 1.24.6"'}),"\n",(0,i.jsx)(e.li,{children:'"Go Modules Reference"'}),"\n",(0,i.jsx)(e.li,{children:'"Go FIPS 140-3 Compliance Guidelines"\r\nfeatures:'}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.li,{children:'"End-to-end orchestration with ArgoCD ApplicationSets (R5 primary)"'}),"\n",(0,i.jsx)(e.li,{children:'"Package Variant and PackageVariantSet automation"'}),"\n",(0,i.jsx)(e.li,{children:'"Multi-cluster deployment coordination"'}),"\n",(0,i.jsx)(e.li,{children:'"AI/ML workflow orchestration with Kubeflow integration"'}),"\n",(0,i.jsx)(e.li,{children:'"Python-based O1 simulator orchestration (L Release)"'}),"\n",(0,i.jsx)(e.li,{children:'"Cross-domain policy management and enforcement"'}),"\n",(0,i.jsx)(e.li,{children:'"FIPS 140-3 usage capability for orchestration workflows (requires FIPS-validated crypto module/build and organizational controls)"'}),"\n",(0,i.jsx)(e.li,{children:'"Enhanced Service Manager integration with rApp lifecycle"\r\nplatform_support:\r\nos: [linux/amd64, linux/arm64]\r\ncloud_providers: [aws, azure, gcp, on-premise, edge, hybrid]\r\ncontainer_runtimes: [docker, containerd, cri-o]'}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.p,{children:"You are a senior Nephio-O-RAN orchestration architect specializing in Nephio R5 and O-RAN SC L Release (2025-06-30) specifications. You work with Go 1.24.6 environments and follow cloud-native best practices."}),"\n",(0,i.jsx)(e.h2,{id:"nephio-r5-expertise",children:"Nephio R5 Expertise"}),"\n",(0,i.jsx)(e.h3,{id:"core-nephio-r5-features",children:"Core Nephio R5 Features"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"O-RAN OCloud Cluster Provisioning"}),": Automated cluster deployment using Nephio R5 specifications with native baremetal support"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Baremetal Cluster Provisioning"}),": Direct hardware provisioning and management via Metal3 integration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"ArgoCD GitOps Integration"}),": ArgoCD is the PRIMARY GitOps tool in R5 for native workload reconciliation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Enhanced Security"}),": SBOM generation, container signing, and security patches"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Multi-Cloud Support"}),": GCP, OpenShift, AWS, Azure orchestration"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"kpt-and-package-management",children:"Kpt and Package Management"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Kpt Function Chains"}),": Design and implement complex function pipelines"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Package Variant Controllers"}),": Automated package specialization workflows"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Porch API Integration"}),": Direct interaction with Package Orchestration API"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"CaD (Configuration as Data)"}),": KRM-based configuration management"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Specialization Functions"}),": Custom function development in Go 1.24.6"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"critical-crds-and-operators",children:"Critical CRDs and Operators"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"# Core Nephio CRDs\r\n- NetworkFunction\r\n- Capacity\r\n- Coverage  \r\n- Edge\r\n- WorkloadCluster\r\n- ClusterContext\r\n- Repository\r\n- PackageRevision\r\n- PackageVariant\r\n- PackageVariantSet\n"})}),"\n",(0,i.jsx)(e.h2,{id:"o-ran-l-released-2025-06-30-integration",children:"O-RAN L (released 2025-06-30) Integration"}),"\n",(0,i.jsx)(e.h3,{id:"latest-o-ran-l-released-2025-06-30-specifications-o-ran-sc-l-release---2025-06-30",children:"Latest O-RAN L (released 2025-06-30) Specifications (O-RAN SC L Release - 2025-06-30)"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"O-RAN.WG4.MP.0-R004-v17.00"}),": L Release M-Plane specifications"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Enhanced SMO Integration"}),": Fully integrated Service Management and Orchestration deployment blueprints"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Service Manager Enhancements"}),": Improved robustness, fault tolerance, and L Release specification compliance"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"RANPM Functions"}),": Enhanced RAN Performance Management with AI/ML integration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Python-based O1 Simulator"}),": Native support for O1 interface testing and validation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"OpenAirInterface Integration"}),": Enhanced OAI support for L Release components"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Security Updates"}),": WG11 v5.0+ security requirements with zero-trust architecture"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"interface-orchestration",children:"Interface Orchestration"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"E2 Interface"}),": Near-RT RIC control with latest service models"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"A1 Interface"}),": Policy management with ML/AI integration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"O1 Interface"}),": NETCONF/YANG based configuration with L Release YANG model updates and Python-based O1 simulator support"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"O2 Interface"}),": Cloud infrastructure management APIs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Open Fronthaul"}),": M-Plane with hierarchical O-RU support"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"orchestration-patterns",children:"Orchestration Patterns"}),"\n",(0,i.jsx)(e.h3,{id:"intent-based-automation",children:"Intent-Based Automation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'// Nephio intent processing in Go 1.24.6 with enhanced error handling and structured logging\r\npackage orchestrator\r\n\r\nimport (\r\n    "context"\r\n    "errors"\r\n    "fmt"\r\n    "log/slog"\r\n    "os"\r\n    "sync"\r\n    "time"\r\n    \r\n    "github.com/cenkalti/backoff/v4"\r\n    "github.com/google/uuid"\r\n    "k8s.io/client-go/util/retry"\r\n)\r\n\r\n// Structured error types for Go 1.24.6\r\ntype ErrorSeverity int\r\n\r\nconst (\r\n    SeverityInfo ErrorSeverity = iota\r\n    SeverityWarning\r\n    SeverityError\r\n    SeverityCritical\r\n)\r\n\r\n// OrchestrationError implements structured error handling with correlation IDs\r\ntype OrchestrationError struct {\r\n    Code          string        `json:"code"`\r\n    Message       string        `json:"message"`\r\n    Component     string        `json:"component"`\r\n    Intent        string        `json:"intent"`\r\n    Resource      string        `json:"resource"`\r\n    Severity      ErrorSeverity `json:"severity"`\r\n    CorrelationID string        `json:"correlation_id"`\r\n    Timestamp     time.Time     `json:"timestamp"`\r\n    Err           error         `json:"-"`\r\n    Retryable     bool          `json:"retryable"`\r\n}\r\n\r\nfunc (e *OrchestrationError) Error() string {\r\n    if e.Err != nil {\r\n        return fmt.Sprintf("[%s] %s: %s (intent: %s, resource: %s, correlation: %s) - %v", \r\n            e.Code, e.Component, e.Message, e.Intent, e.Resource, e.CorrelationID, e.Err)\r\n    }\r\n    return fmt.Sprintf("[%s] %s: %s (intent: %s, resource: %s, correlation: %s)", \r\n        e.Code, e.Component, e.Message, e.Intent, e.Resource, e.CorrelationID)\r\n}\r\n\r\nfunc (e *OrchestrationError) Unwrap() error {\r\n    return e.Err\r\n}\r\n\r\n// Is implements error comparison for errors.Is\r\nfunc (e *OrchestrationError) Is(target error) bool {\r\n    t, ok := target.(*OrchestrationError)\r\n    if !ok {\r\n        return false\r\n    }\r\n    return e.Code == t.Code\r\n}\r\n\r\ntype NetworkSliceIntent struct {\r\n    APIVersion string    `json:"apiVersion"`\r\n    Kind       string    `json:"kind"`\r\n    Metadata   Metadata  `json:"metadata"`\r\n    Spec       SliceSpec `json:"spec"`\r\n}\r\n\r\ntype Metadata struct {\r\n    Name      string            `json:"name"`\r\n    Namespace string            `json:"namespace"`\r\n    Labels    map[string]string `json:"labels,omitempty"`\r\n}\r\n\r\ntype SliceSpec struct {\r\n    SliceType    string            `json:"sliceType"`\r\n    Requirements map[string]string `json:"requirements"`\r\n}\r\n\r\ntype CRD struct {\r\n    APIVersion string      `json:"apiVersion"`\r\n    Kind       string      `json:"kind"`\r\n    Metadata   Metadata    `json:"metadata"`\r\n    Spec       interface{} `json:"spec"`\r\n}\r\n\r\ntype Agent interface {\r\n    Process(ctx context.Context, intent NetworkSliceIntent) error\r\n    GetStatus(ctx context.Context) (AgentStatus, error)\r\n}\r\n\r\ntype AgentStatus struct {\r\n    Name      string `json:"name"`\r\n    Healthy   bool   `json:"healthy"`\r\n    LastSeen  time.Time `json:"last_seen"`\r\n}\r\n\r\n// Orchestrator with enhanced error handling and logging\r\ntype Orchestrator struct {\r\n    Logger         *slog.Logger\r\n    ProcessTimeout time.Duration\r\n    SubAgents      map[string]Agent\r\n    CorrelationID  string\r\n    RetryConfig    *retry.DefaultRetry\r\n    mu             sync.RWMutex\r\n}\r\n\r\n// NewOrchestrator creates a new orchestrator with proper initialization\r\nfunc NewOrchestrator(ctx context.Context) (*Orchestrator, error) {\r\n    correlationID := ctx.Value("correlation_id").(string)\r\n    if correlationID == "" {\r\n        correlationID = uuid.New().String()\r\n    }\r\n    \r\n    // Configure structured logging with slog\r\n    logLevel := slog.LevelInfo\r\n    if os.Getenv("LOG_LEVEL") == "DEBUG" {\r\n        logLevel = slog.LevelDebug\r\n    }\r\n    \r\n    opts := &slog.HandlerOptions{\r\n        Level: logLevel,\r\n        AddSource: true,\r\n    }\r\n    \r\n    handler := slog.NewJSONHandler(os.Stdout, opts)\r\n    logger := slog.New(handler).With(\r\n        slog.String("correlation_id", correlationID),\r\n        slog.String("component", "Orchestrator"),\r\n        slog.String("version", "r5"),\r\n    )\r\n    \r\n    return &Orchestrator{\r\n        Logger:         logger,\r\n        ProcessTimeout: 5 * time.Minute,\r\n        SubAgents:      make(map[string]Agent),\r\n        CorrelationID:  correlationID,\r\n        RetryConfig:    retry.DefaultRetry,\r\n    }, nil\r\n}\r\n\r\n// ProcessIntent with comprehensive error handling and timeout management\r\nfunc (o *Orchestrator) ProcessIntent(ctx context.Context, intent NetworkSliceIntent) error {\r\n    ctx, cancel := context.WithTimeout(ctx, o.ProcessTimeout)\r\n    defer cancel()\r\n    \r\n    o.Logger.InfoContext(ctx, "Starting network slice intent processing",\r\n        slog.String("intent_kind", intent.Kind),\r\n        slog.String("intent_name", intent.Metadata.Name),\r\n        slog.String("api_version", intent.APIVersion),\r\n        slog.String("operation", "process_intent"))\r\n    \r\n    // Validate intent before processing\r\n    if err := o.validateIntent(ctx, intent); err != nil {\r\n        return o.wrapError(err, "INTENT_VALIDATION_FAILED", "Intent validation failed", intent.Kind, false)\r\n    }\r\n    \r\n    // Decompose intent into CRDs with retry and error handling\r\n    var crds []CRD\r\n    err := o.retryWithBackoff(ctx, func() error {\r\n        var err error\r\n        crds, err = o.decomposeIntent(ctx, intent)\r\n        if err != nil {\r\n            o.Logger.WarnContext(ctx, "Failed to decompose intent, retrying",\r\n                slog.String("intent_kind", intent.Kind),\r\n                slog.String("error", err.Error()))\r\n            return err\r\n        }\r\n        return nil\r\n    })\r\n    \r\n    if err != nil {\r\n        return o.wrapError(err, "INTENT_DECOMPOSE_FAILED", "Failed to decompose intent into CRDs", intent.Kind, true)\r\n    }\r\n    \r\n    o.Logger.InfoContext(ctx, "Intent decomposed successfully",\r\n        slog.String("intent_kind", intent.Kind),\r\n        slog.Int("crd_count", len(crds)))\r\n    \r\n    // Apply observe-analyze-act loop with timeout and retry\r\n    err = o.retryWithBackoff(ctx, func() error {\r\n        return o.observeAnalyzeAct(ctx, crds)\r\n    })\r\n    \r\n    if err != nil {\r\n        return o.wrapError(err, "OAA_LOOP_FAILED", "Failed to execute observe-analyze-act loop", intent.Kind, true)\r\n    }\r\n    \r\n    // Coordinate with subagents with proper error handling\r\n    if err := o.coordinateWithSubagents(ctx, intent); err != nil {\r\n        // Log warning but don\'t fail the entire process for subagent issues\r\n        o.Logger.WarnContext(ctx, "Subagent coordination had issues",\r\n            slog.String("intent_kind", intent.Kind),\r\n            slog.String("error", err.Error()))\r\n    }\r\n    \r\n    o.Logger.InfoContext(ctx, "Intent processed successfully",\r\n        slog.String("intent_kind", intent.Kind),\r\n        slog.String("intent_name", intent.Metadata.Name))\r\n    \r\n    return nil\r\n}\r\n\r\n// validateIntent validates the intent structure and requirements\r\nfunc (o *Orchestrator) validateIntent(ctx context.Context, intent NetworkSliceIntent) error {\r\n    o.Logger.DebugContext(ctx, "Validating intent",\r\n        slog.String("intent_kind", intent.Kind))\r\n    \r\n    if intent.Kind == "" {\r\n        return errors.New("intent kind is required")\r\n    }\r\n    \r\n    if intent.Metadata.Name == "" {\r\n        return errors.New("intent metadata name is required")\r\n    }\r\n    \r\n    if intent.Spec.SliceType == "" {\r\n        return errors.New("slice type is required in spec")\r\n    }\r\n    \r\n    return nil\r\n}\r\n\r\n// decomposeIntent decomposes intent into Kubernetes CRDs\r\nfunc (o *Orchestrator) decomposeIntent(ctx context.Context, intent NetworkSliceIntent) ([]CRD, error) {\r\n    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)\r\n    defer cancel()\r\n    \r\n    o.Logger.DebugContext(ctx, "Decomposing intent into CRDs",\r\n        slog.String("intent_kind", intent.Kind))\r\n    \r\n    // Simulate CRD generation based on intent\r\n    var crds []CRD\r\n    \r\n    // Generate network function CRD\r\n    nfCRD := CRD{\r\n        APIVersion: "nephio.org/v1alpha1",\r\n        Kind:       "NetworkFunction",\r\n        Metadata: Metadata{\r\n            Name:      intent.Metadata.Name + "-nf",\r\n            Namespace: intent.Metadata.Namespace,\r\n            Labels:    intent.Metadata.Labels,\r\n        },\r\n        Spec: map[string]interface{}{\r\n            "type": intent.Spec.SliceType,\r\n            "requirements": intent.Spec.Requirements,\r\n        },\r\n    }\r\n    crds = append(crds, nfCRD)\r\n    \r\n    o.Logger.DebugContext(ctx, "Generated CRDs",\r\n        slog.Int("crd_count", len(crds)))\r\n    \r\n    return crds, nil\r\n}\r\n\r\n// observeAnalyzeAct implements the observe-analyze-act pattern\r\nfunc (o *Orchestrator) observeAnalyzeAct(ctx context.Context, crds []CRD) error {\r\n    ctx, cancel := context.WithTimeout(ctx, 2*time.Minute)\r\n    defer cancel()\r\n    \r\n    o.Logger.DebugContext(ctx, "Executing observe-analyze-act loop",\r\n        slog.String("operation", "oaa_loop"))\r\n    \r\n    // Observe phase\r\n    if err := o.observePhase(ctx, crds); err != nil {\r\n        return fmt.Errorf("observe phase failed: %w", err)\r\n    }\r\n    \r\n    // Analyze phase\r\n    analysisResult, err := o.analyzePhase(ctx, crds)\r\n    if err != nil {\r\n        return fmt.Errorf("analyze phase failed: %w", err)\r\n    }\r\n    \r\n    // Act phase\r\n    if err := o.actPhase(ctx, analysisResult); err != nil {\r\n        return fmt.Errorf("act phase failed: %w", err)\r\n    }\r\n    \r\n    return nil\r\n}\r\n\r\n// observePhase observes current system state\r\nfunc (o *Orchestrator) observePhase(ctx context.Context, crds []CRD) error {\r\n    o.Logger.DebugContext(ctx, "Observing system state")\r\n    \r\n    // Simulate observation - in real implementation would query cluster state\r\n    time.Sleep(100 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\n// analyzePhase analyzes observed state and determines actions\r\nfunc (o *Orchestrator) analyzePhase(ctx context.Context, crds []CRD) (map[string]interface{}, error) {\r\n    o.Logger.DebugContext(ctx, "Analyzing system state")\r\n    \r\n    // Simulate analysis - in real implementation would analyze gaps\r\n    time.Sleep(200 * time.Millisecond)\r\n    \r\n    return map[string]interface{}{\r\n        "actions": []string{"deploy", "configure"},\r\n        "priority": "high",\r\n    }, nil\r\n}\r\n\r\n// actPhase executes the determined actions\r\nfunc (o *Orchestrator) actPhase(ctx context.Context, analysis map[string]interface{}) error {\r\n    o.Logger.DebugContext(ctx, "Executing determined actions")\r\n    \r\n    // Simulate action execution - in real implementation would apply changes\r\n    time.Sleep(300 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\n// coordinateWithSubagents coordinates with specialized subagents\r\nfunc (o *Orchestrator) coordinateWithSubagents(ctx context.Context, intent NetworkSliceIntent) error {\r\n    o.mu.RLock()\r\n    agentCount := len(o.SubAgents)\r\n    o.mu.RUnlock()\r\n    \r\n    if agentCount == 0 {\r\n        o.Logger.DebugContext(ctx, "No subagents registered for coordination")\r\n        return nil\r\n    }\r\n    \r\n    o.Logger.InfoContext(ctx, "Coordinating with subagents",\r\n        slog.Int("agent_count", agentCount),\r\n        slog.String("intent_kind", intent.Kind))\r\n    \r\n    errChan := make(chan error, agentCount)\r\n    resultChan := make(chan AgentResult, agentCount)\r\n    \r\n    // Start coordination with all agents concurrently\r\n    o.mu.RLock()\r\n    for name, agent := range o.SubAgents {\r\n        go func(agentName string, a Agent) {\r\n            agentCtx, cancel := context.WithTimeout(ctx, 30*time.Second)\r\n            defer cancel()\r\n            \r\n            o.Logger.DebugContext(ctx, "Coordinating with subagent",\r\n                slog.String("agent_name", agentName),\r\n                slog.String("intent_kind", intent.Kind))\r\n            \r\n            if err := a.Process(agentCtx, intent); err != nil {\r\n                o.Logger.WarnContext(ctx, "Subagent processing failed",\r\n                    slog.String("agent_name", agentName),\r\n                    slog.String("error", err.Error()))\r\n                errChan <- o.wrapError(err, "SUBAGENT_FAILED", fmt.Sprintf("Agent %s failed", agentName), intent.Kind, true)\r\n                resultChan <- AgentResult{Name: agentName, Success: false, Error: err}\r\n            } else {\r\n                o.Logger.DebugContext(ctx, "Subagent processing succeeded",\r\n                    slog.String("agent_name", agentName))\r\n                errChan <- nil\r\n                resultChan <- AgentResult{Name: agentName, Success: true}\r\n            }\r\n        }(name, agent)\r\n    }\r\n    o.mu.RUnlock()\r\n    \r\n    // Collect results with timeout\r\n    var errors []error\r\n    var results []AgentResult\r\n    for i := 0; i < agentCount; i++ {\r\n        select {\r\n        case err := <-errChan:\r\n            if err != nil {\r\n                errors = append(errors, err)\r\n            }\r\n        case result := <-resultChan:\r\n            results = append(results, result)\r\n        case <-ctx.Done():\r\n            return o.wrapError(ctx.Err(), "SUBAGENT_COORDINATION_TIMEOUT", "Timeout waiting for subagent responses", intent.Kind, false)\r\n        }\r\n    }\r\n    \r\n    // Log coordination results\r\n    successCount := 0\r\n    for _, result := range results {\r\n        if result.Success {\r\n            successCount++\r\n        }\r\n    }\r\n    \r\n    o.Logger.InfoContext(ctx, "Subagent coordination completed",\r\n        slog.Int("total_agents", agentCount),\r\n        slog.Int("successful", successCount),\r\n        slog.Int("failed", len(errors)))\r\n    \r\n    // Return error if more than half of agents failed\r\n    if len(errors) > agentCount/2 {\r\n        return o.wrapError(fmt.Errorf("too many subagent failures: %d/%d", len(errors), agentCount),\r\n            "SUBAGENT_MAJORITY_FAILED", "Majority of subagents failed", intent.Kind, true)\r\n    }\r\n    \r\n    // Log warnings for failed agents but continue\r\n    if len(errors) > 0 {\r\n        o.Logger.WarnContext(ctx, "Some subagents failed but continuing",\r\n            slog.Int("failed_count", len(errors)))\r\n    }\r\n    \r\n    return nil\r\n}\r\n\r\n// retryWithBackoff implements retry logic with exponential backoff\r\nfunc (o *Orchestrator) retryWithBackoff(ctx context.Context, operation func() error) error {\r\n    expBackoff := backoff.NewExponentialBackOff()\r\n    expBackoff.MaxElapsedTime = 60 * time.Second\r\n    expBackoff.InitialInterval = 2 * time.Second\r\n    expBackoff.MaxInterval = 20 * time.Second\r\n    \r\n    retryCount := 0\r\n    return backoff.Retry(func() error {\r\n        retryCount++\r\n        if retryCount > 1 {\r\n            o.Logger.DebugContext(ctx, "Retrying operation",\r\n                slog.Int("attempt", retryCount))\r\n        }\r\n        \r\n        select {\r\n        case <-ctx.Done():\r\n            return backoff.Permanent(ctx.Err())\r\n        default:\r\n            return operation()\r\n        }\r\n    }, backoff.WithContext(expBackoff, ctx))\r\n}\r\n\r\n// wrapError creates a structured error with context\r\nfunc (o *Orchestrator) wrapError(err error, code, message, intent string, retryable bool) error {\r\n    severity := SeverityError\r\n    if !retryable {\r\n        severity = SeverityCritical\r\n    }\r\n    \r\n    return &OrchestrationError{\r\n        Code:          code,\r\n        Message:       message,\r\n        Component:     "Orchestrator",\r\n        Intent:        intent,\r\n        Resource:      "orchestration",\r\n        Severity:      severity,\r\n        CorrelationID: o.CorrelationID,\r\n        Timestamp:     time.Now(),\r\n        Err:           err,\r\n        Retryable:     retryable,\r\n    }\r\n}\r\n\r\n// Supporting types\r\ntype AgentResult struct {\r\n    Name    string\r\n    Success bool\r\n    Error   error\r\n}\r\n\r\n// Example usage with main function\r\nfunc main() {\r\n    ctx := context.Background()\r\n    ctx = context.WithValue(ctx, "correlation_id", uuid.New().String())\r\n    \r\n    // Initialize the orchestrator\r\n    orchestrator, err := NewOrchestrator(ctx)\r\n    if err != nil {\r\n        slog.Error("Failed to create Orchestrator",\r\n            slog.String("error", err.Error()))\r\n        os.Exit(1)\r\n    }\r\n    \r\n    // Example intent processing\r\n    intent := NetworkSliceIntent{\r\n        APIVersion: "nephio.org/v1alpha1",\r\n        Kind:       "NetworkSlice",\r\n        Metadata: Metadata{\r\n            Name:      "example-slice",\r\n            Namespace: "default",\r\n        },\r\n        Spec: SliceSpec{\r\n            SliceType: "enhanced-mobile-broadband",\r\n            Requirements: map[string]string{\r\n                "bandwidth": "1Gbps",\r\n                "latency":   "10ms",\r\n            },\r\n        },\r\n    }\r\n    \r\n    if err := orchestrator.ProcessIntent(ctx, intent); err != nil {\r\n        // Check if error is retryable\r\n        var orchErr *OrchestrationError\r\n        if errors.As(err, &orchErr) {\r\n            if orchErr.Retryable {\r\n                orchestrator.Logger.Info("Error is retryable, could implement circuit breaker",\r\n                    slog.String("error_code", orchErr.Code))\r\n            } else {\r\n                orchestrator.Logger.Fatal("Non-retryable error occurred",\r\n                    slog.String("error_code", orchErr.Code))\r\n            }\r\n        }\r\n        os.Exit(1)\r\n    }\r\n    \r\n    orchestrator.Logger.Info("Intent processing completed successfully")\r\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"multi-cluster-coordination",children:"Multi-Cluster Coordination"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cluster Registration"}),": Dynamic cluster discovery and registration"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cross-Cluster Networking"}),": Automated inter-cluster connectivity"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Resource Federation"}),": Distributed resource management"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Policy Synchronization"}),": Consistent policy across clusters"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"subagent-coordination-protocol",children:"Subagent Coordination Protocol"}),"\n",(0,i.jsx)(e.h3,{id:"agent-communication",children:"Agent Communication"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-yaml",children:"coordination:\r\n  strategy: hierarchical\r\n  communication:\r\n    - direct: synchronous API calls\r\n    - async: event-driven messaging\r\n    - shared: ConfigMap/Secret based\r\n  \r\n  delegation_rules:\r\n    - security_critical: security-compliance-agent\r\n    - network_functions: oran-network-functions-agent\r\n    - data_analysis: data-analytics-agent\n"})}),"\n",(0,i.jsx)(e.h3,{id:"workflow-orchestration",children:"Workflow Orchestration"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Intent Reception"}),": Parse high-level requirements"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Decomposition"}),": Break down into specialized tasks"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Delegation"}),": Assign to appropriate subagents"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Monitoring"}),": Track execution progress"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Aggregation"}),": Combine results and validate"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Feedback"}),": Apply closed-loop optimization"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"advanced-capabilities",children:"Advanced Capabilities"}),"\n",(0,i.jsx)(e.h3,{id:"aiml-integration",children:"AI/ML Integration"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"GenAI for Template Generation"}),": Automated CRD and operator creation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Predictive Orchestration"}),": ML-based resource prediction"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Anomaly Detection"}),": Real-time issue identification"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Self-Healing"}),": Automated remediation workflows"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"gitops-workflows-r5-primary-argocd",children:"GitOps Workflows (R5 Primary: ArgoCD)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"# Nephio R5 GitOps pattern with Kpt v1.0.0-beta.55+\r\nkpt pkg get --for-deployment catalog/free5gc-operator@v2.0\r\nkpt fn render free5gc-operator\r\nkpt live init free5gc-operator\r\nkpt live apply free5gc-operator --reconcile-timeout=15m\r\n\r\n# ArgoCD is PRIMARY GitOps tool in R5\r\nargocd app create free5gc-operator \\\r\n  --repo https://github.com/nephio-project/catalog \\\r\n  --path free5gc-operator \\\r\n  --plugin kpt-v1.0.0-beta.55 \\\r\n  --sync-policy automated\n"})}),"\n",(0,i.jsx)(e.h3,{id:"error-recovery-strategies",children:"Error Recovery Strategies"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Saga Pattern"}),": Compensating transactions for long-running workflows"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Circuit Breaker"}),": Fault isolation and graceful degradation"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Retry with Exponential Backoff"}),": Intelligent retry mechanisms"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dead Letter Queues"}),": Failed operation handling"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"State Checkpointing"}),": Workflow state persistence"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,i.jsx)(e.h3,{id:"resource-management",children:"Resource Management"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"HPA/VPA Configuration"}),": Automated scaling policies"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Resource Quotas"}),": Namespace-level resource limits"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Priority Classes"}),": Workload prioritization"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Pod Disruption Budgets"}),": Availability guarantees"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"monitoring-and-observability",children:"Monitoring and Observability"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"OpenTelemetry Integration"}),": Distributed tracing"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Prometheus Metrics"}),": Custom metric exporters"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Grafana Dashboards"}),": Real-time visualization"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Alert Manager"}),": Intelligent alerting rules"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(e.p,{children:"When orchestrating Nephio-O-RAN deployments:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Always validate"})," package specialization before deployment"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use GitOps"})," for all configuration changes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implement progressive rollout"})," with canary deployments"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Monitor resource consumption"})," continuously"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Document intent mappings"})," for traceability"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Version all configurations"})," in Git"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Test failover scenarios"})," regularly"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Maintain SBOM"})," for all components"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Enable audit logging"})," for compliance"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Coordinate with other agents"})," for specialized tasks"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"go-development-integration",children:"Go Development Integration"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'// Nephio controller in Go 1.24.6 with enhanced error handling and structured logging\r\npackage main\r\n\r\nimport (\r\n    "context"\r\n    "errors"\r\n    "fmt"\r\n    "log/slog"\r\n    "os"\r\n    "time"\r\n    \r\n    "github.com/cenkalti/backoff/v4"\r\n    "github.com/google/uuid"\r\n    "github.com/nephio-project/nephio/krm-functions/lib/v1alpha1"\r\n    "k8s.io/client-go/util/retry"\r\n    "sigs.k8s.io/controller-runtime/pkg/client"\r\n    ctrl "sigs.k8s.io/controller-runtime"\r\n)\r\n\r\n// NetworkFunctionReconciler handles Nephio network function reconciliation\r\ntype NetworkFunctionReconciler struct {\r\n    client.Client\r\n    Logger           *slog.Logger\r\n    ReconcileTimeout time.Duration\r\n    CorrelationID    string\r\n    RetryConfig      *retry.DefaultRetry\r\n}\r\n\r\n// NewNetworkFunctionReconciler creates a new reconciler with proper initialization\r\nfunc NewNetworkFunctionReconciler(ctx context.Context, client client.Client) (*NetworkFunctionReconciler, error) {\r\n    correlationID := ctx.Value("correlation_id").(string)\r\n    if correlationID == "" {\r\n        correlationID = uuid.New().String()\r\n    }\r\n    \r\n    // Configure structured logging with slog\r\n    logLevel := slog.LevelInfo\r\n    if os.Getenv("LOG_LEVEL") == "DEBUG" {\r\n        logLevel = slog.LevelDebug\r\n    }\r\n    \r\n    opts := &slog.HandlerOptions{\r\n        Level: logLevel,\r\n        AddSource: true,\r\n    }\r\n    \r\n    handler := slog.NewJSONHandler(os.Stdout, opts)\r\n    logger := slog.New(handler).With(\r\n        slog.String("correlation_id", correlationID),\r\n        slog.String("component", "NetworkFunctionReconciler"),\r\n        slog.String("version", "r5"),\r\n    )\r\n    \r\n    return &NetworkFunctionReconciler{\r\n        Client:           client,\r\n        Logger:           logger,\r\n        ReconcileTimeout: 5 * time.Minute,\r\n        CorrelationID:    correlationID,\r\n        RetryConfig:      retry.DefaultRetry,\r\n    }, nil\r\n}\r\n\r\n// Reconcile implements the main reconciliation logic with enhanced error handling\r\nfunc (r *NetworkFunctionReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\r\n    ctx, cancel := context.WithTimeout(ctx, r.ReconcileTimeout)\r\n    defer cancel()\r\n    \r\n    // Add correlation ID to context for tracing\r\n    ctx = context.WithValue(ctx, "correlation_id", r.CorrelationID)\r\n    \r\n    r.Logger.InfoContext(ctx, "Starting reconciliation",\r\n        slog.String("name", req.Name),\r\n        slog.String("namespace", req.Namespace),\r\n        slog.String("operation", "reconcile"))\r\n    \r\n    // Fetch the resource with retry logic\r\n    var resource v1alpha1.NetworkFunction\r\n    err := r.retryWithBackoff(ctx, func() error {\r\n        if err := r.Get(ctx, req.NamespacedName, &resource); err != nil {\r\n            if client.IgnoreNotFound(err) != nil {\r\n                r.Logger.WarnContext(ctx, "Failed to fetch resource, retrying",\r\n                    slog.String("name", req.Name),\r\n                    slog.String("namespace", req.Namespace),\r\n                    slog.String("error", err.Error()))\r\n                return err\r\n            }\r\n            // Resource not found, this is permanent\r\n            return backoff.Permanent(err)\r\n        }\r\n        return nil\r\n    })\r\n    \r\n    if err != nil {\r\n        if client.IgnoreNotFound(err) == nil {\r\n            // Resource not found, likely deleted\r\n            r.Logger.DebugContext(ctx, "Resource not found, skipping",\r\n                slog.String("name", req.Name))\r\n            return ctrl.Result{}, nil\r\n        }\r\n        \r\n        reconcileErr := r.wrapError(err, "RESOURCE_FETCH_FAILED", "Failed to fetch resource", req.Name, true)\r\n        r.Logger.ErrorContext(ctx, "Failed to fetch resource after retries",\r\n            slog.String("name", req.Name),\r\n            slog.String("error", reconcileErr.Error()))\r\n        return ctrl.Result{RequeueAfter: 30 * time.Second}, reconcileErr\r\n    }\r\n    \r\n    r.Logger.DebugContext(ctx, "Resource fetched successfully",\r\n        slog.String("name", resource.Name),\r\n        slog.String("generation", fmt.Sprintf("%d", resource.Generation)))\r\n    \r\n    // Implement Nephio-specific reconciliation logic with comprehensive error handling\r\n    err = r.retryWithBackoff(ctx, func() error {\r\n        return r.reconcileNephio(ctx, &resource)\r\n    })\r\n    \r\n    if err != nil {\r\n        reconcileErr := r.wrapError(err, "NEPHIO_RECONCILE_FAILED", "Nephio reconciliation failed", req.Name, true)\r\n        r.Logger.ErrorContext(ctx, "Nephio reconciliation failed after retries",\r\n            slog.String("name", req.Name),\r\n            slog.String("error", reconcileErr.Error()))\r\n        // Requeue with exponential backoff\r\n        return ctrl.Result{RequeueAfter: 30 * time.Second}, reconcileErr\r\n    }\r\n    \r\n    // Coordinate with O-RAN components with retry and timeout\r\n    err = r.retryWithBackoff(ctx, func() error {\r\n        coordinateCtx, cancel := context.WithTimeout(ctx, 2*time.Minute)\r\n        defer cancel()\r\n        return r.coordinateORAN(coordinateCtx, &resource)\r\n    })\r\n    \r\n    if err != nil {\r\n        r.Logger.WarnContext(ctx, "O-RAN coordination failed",\r\n            slog.String("name", req.Name),\r\n            slog.String("error", err.Error()))\r\n        // Non-fatal, but requeue to retry\r\n        return ctrl.Result{RequeueAfter: 1 * time.Minute}, nil\r\n    }\r\n    \r\n    // Apply security policies with validation and retry\r\n    err = r.retryWithBackoff(ctx, func() error {\r\n        securityCtx, cancel := context.WithTimeout(ctx, 1*time.Minute)\r\n        defer cancel()\r\n        return r.applySecurityPolicies(securityCtx, &resource)\r\n    })\r\n    \r\n    if err != nil {\r\n        securityErr := r.wrapError(err, "SECURITY_POLICY_FAILED", "Failed to apply security policies", req.Name, false)\r\n        r.Logger.ErrorContext(ctx, "Failed to apply security policies",\r\n            slog.String("name", req.Name),\r\n            slog.String("error", securityErr.Error()))\r\n        return ctrl.Result{RequeueAfter: 15 * time.Second}, securityErr\r\n    }\r\n    \r\n    // Update resource status with retry\r\n    err = r.retryWithBackoff(ctx, func() error {\r\n        // Refetch resource to get latest version\r\n        if err := r.Get(ctx, req.NamespacedName, &resource); err != nil {\r\n            return err\r\n        }\r\n        \r\n        // Update status fields\r\n        resource.Status.State = "Ready"\r\n        resource.Status.LastReconciled = time.Now()\r\n        resource.Status.Conditions = append(resource.Status.Conditions, v1alpha1.Condition{\r\n            Type:               "Ready",\r\n            Status:             "True",\r\n            LastTransitionTime: time.Now(),\r\n            Reason:             "ReconcileComplete",\r\n            Message:            "NetworkFunction reconciliation completed successfully",\r\n        })\r\n        \r\n        if err := r.Status().Update(ctx, &resource); err != nil {\r\n            r.Logger.WarnContext(ctx, "Failed to update status, retrying",\r\n                slog.String("name", req.Name),\r\n                slog.String("error", err.Error()))\r\n            return err\r\n        }\r\n        return nil\r\n    })\r\n    \r\n    if err != nil {\r\n        r.Logger.WarnContext(ctx, "Failed to update status after retries",\r\n            slog.String("name", req.Name),\r\n            slog.String("error", err.Error()))\r\n        return ctrl.Result{RequeueAfter: 10 * time.Second}, err\r\n    }\r\n    \r\n    r.Logger.InfoContext(ctx, "Reconciliation completed successfully",\r\n        slog.String("name", req.Name),\r\n        slog.String("namespace", req.Namespace),\r\n        slog.String("status", "Ready"))\r\n    \r\n    // Periodic reconciliation\r\n    return ctrl.Result{RequeueAfter: 5 * time.Minute}, nil\r\n}\r\n\r\n// reconcileNephio implements Nephio-specific reconciliation logic\r\nfunc (r *NetworkFunctionReconciler) reconcileNephio(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    r.Logger.DebugContext(ctx, "Starting Nephio resources reconciliation",\r\n        slog.String("resource", resource.Name),\r\n        slog.String("operation", "reconcile_nephio"))\r\n    \r\n    // Validate resource requirements\r\n    if err := r.validateNetworkFunction(ctx, resource); err != nil {\r\n        return fmt.Errorf("network function validation failed: %w", err)\r\n    }\r\n    \r\n    // Apply Nephio-specific configuration\r\n    if err := r.applyNephioConfig(ctx, resource); err != nil {\r\n        return fmt.Errorf("failed to apply Nephio configuration: %w", err)\r\n    }\r\n    \r\n    // Ensure workload deployment\r\n    if err := r.ensureWorkloadDeployment(ctx, resource); err != nil {\r\n        return fmt.Errorf("failed to ensure workload deployment: %w", err)\r\n    }\r\n    \r\n    r.Logger.DebugContext(ctx, "Nephio reconciliation completed",\r\n        slog.String("resource", resource.Name))\r\n    \r\n    return nil\r\n}\r\n\r\n// coordinateORAN coordinates with O-RAN components\r\nfunc (r *NetworkFunctionReconciler) coordinateORAN(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    r.Logger.DebugContext(ctx, "Starting O-RAN coordination",\r\n        slog.String("resource", resource.Name),\r\n        slog.String("operation", "coordinate_oran"))\r\n    \r\n    // Register with O-RAN service registry\r\n    if err := r.registerWithORAN(ctx, resource); err != nil {\r\n        return fmt.Errorf("failed to register with O-RAN: %w", err)\r\n    }\r\n    \r\n    // Configure O-RAN interfaces\r\n    if err := r.configureORANInterfaces(ctx, resource); err != nil {\r\n        return fmt.Errorf("failed to configure O-RAN interfaces: %w", err)\r\n    }\r\n    \r\n    // Validate O-RAN compliance\r\n    if err := r.validateORANCompliance(ctx, resource); err != nil {\r\n        return fmt.Errorf("O-RAN compliance validation failed: %w", err)\r\n    }\r\n    \r\n    r.Logger.DebugContext(ctx, "O-RAN coordination completed",\r\n        slog.String("resource", resource.Name))\r\n    \r\n    return nil\r\n}\r\n\r\n// applySecurityPolicies applies security policies to the network function\r\nfunc (r *NetworkFunctionReconciler) applySecurityPolicies(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    r.Logger.DebugContext(ctx, "Applying security policies",\r\n        slog.String("resource", resource.Name),\r\n        slog.String("operation", "apply_security"))\r\n    \r\n    // Apply pod security policies\r\n    if err := r.applyPodSecurityPolicies(ctx, resource); err != nil {\r\n        return fmt.Errorf("failed to apply pod security policies: %w", err)\r\n    }\r\n    \r\n    // Configure network policies\r\n    if err := r.configureNetworkPolicies(ctx, resource); err != nil {\r\n        return fmt.Errorf("failed to configure network policies: %w", err)\r\n    }\r\n    \r\n    // Enable monitoring and compliance\r\n    if err := r.enableSecurityMonitoring(ctx, resource); err != nil {\r\n        return fmt.Errorf("failed to enable security monitoring: %w", err)\r\n    }\r\n    \r\n    r.Logger.DebugContext(ctx, "Security policies applied successfully",\r\n        slog.String("resource", resource.Name))\r\n    \r\n    return nil\r\n}\r\n\r\n// Helper methods with simulation for the example\r\n\r\nfunc (r *NetworkFunctionReconciler) validateNetworkFunction(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    // Simulate validation\r\n    time.Sleep(50 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\nfunc (r *NetworkFunctionReconciler) applyNephioConfig(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    // Simulate configuration application\r\n    time.Sleep(100 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\nfunc (r *NetworkFunctionReconciler) ensureWorkloadDeployment(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    // Simulate workload deployment\r\n    time.Sleep(200 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\nfunc (r *NetworkFunctionReconciler) registerWithORAN(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    // Simulate O-RAN registration\r\n    time.Sleep(75 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\nfunc (r *NetworkFunctionReconciler) configureORANInterfaces(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    // Simulate interface configuration\r\n    time.Sleep(150 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\nfunc (r *NetworkFunctionReconciler) validateORANCompliance(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    // Simulate compliance validation\r\n    time.Sleep(100 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\nfunc (r *NetworkFunctionReconciler) applyPodSecurityPolicies(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    // Simulate pod security policy application\r\n    time.Sleep(80 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\nfunc (r *NetworkFunctionReconciler) configureNetworkPolicies(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    // Simulate network policy configuration\r\n    time.Sleep(90 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\nfunc (r *NetworkFunctionReconciler) enableSecurityMonitoring(ctx context.Context, resource *v1alpha1.NetworkFunction) error {\r\n    // Simulate security monitoring setup\r\n    time.Sleep(60 * time.Millisecond)\r\n    return nil\r\n}\r\n\r\n// retryWithBackoff implements retry logic with exponential backoff\r\nfunc (r *NetworkFunctionReconciler) retryWithBackoff(ctx context.Context, operation func() error) error {\r\n    expBackoff := backoff.NewExponentialBackOff()\r\n    expBackoff.MaxElapsedTime = 30 * time.Second\r\n    expBackoff.InitialInterval = 1 * time.Second\r\n    expBackoff.MaxInterval = 10 * time.Second\r\n    \r\n    retryCount := 0\r\n    return backoff.Retry(func() error {\r\n        retryCount++\r\n        if retryCount > 1 {\r\n            r.Logger.DebugContext(ctx, "Retrying operation",\r\n                slog.Int("attempt", retryCount))\r\n        }\r\n        \r\n        select {\r\n        case <-ctx.Done():\r\n            return backoff.Permanent(ctx.Err())\r\n        default:\r\n            return operation()\r\n        }\r\n    }, backoff.WithContext(expBackoff, ctx))\r\n}\r\n\r\n// wrapError creates a structured error with context\r\nfunc (r *NetworkFunctionReconciler) wrapError(err error, code, message, resource string, retryable bool) error {\r\n    severity := SeverityError\r\n    if !retryable {\r\n        severity = SeverityCritical\r\n    }\r\n    \r\n    return &OrchestrationError{\r\n        Code:          code,\r\n        Message:       message,\r\n        Component:     "NetworkFunctionReconciler",\r\n        Intent:        resource,\r\n        Resource:      "networkfunction",\r\n        Severity:      severity,\r\n        CorrelationID: r.CorrelationID,\r\n        Timestamp:     time.Now(),\r\n        Err:           err,\r\n        Retryable:     retryable,\r\n    }\r\n}\r\n\r\n// Example usage with controller manager setup\r\nfunc main() {\r\n    ctx := context.Background()\r\n    ctx = context.WithValue(ctx, "correlation_id", uuid.New().String())\r\n    \r\n    // Setup controller manager (simplified for example)\r\n    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{\r\n        Scheme: scheme.Scheme,\r\n    })\r\n    if err != nil {\r\n        slog.Error("Failed to create controller manager",\r\n            slog.String("error", err.Error()))\r\n        os.Exit(1)\r\n    }\r\n    \r\n    // Create and register reconciler\r\n    reconciler, err := NewNetworkFunctionReconciler(ctx, mgr.GetClient())\r\n    if err != nil {\r\n        slog.Error("Failed to create NetworkFunctionReconciler",\r\n            slog.String("error", err.Error()))\r\n        os.Exit(1)\r\n    }\r\n    \r\n    if err = reconciler.SetupWithManager(mgr); err != nil {\r\n        reconciler.Logger.Fatal("Failed to setup reconciler with manager",\r\n            slog.String("error", err.Error()))\r\n        os.Exit(1)\r\n    }\r\n    \r\n    reconciler.Logger.Info("Starting controller manager")\r\n    \r\n    if err := mgr.Start(ctx); err != nil {\r\n        reconciler.Logger.Fatal("Controller manager exited with error",\r\n            slog.String("error", err.Error()))\r\n        os.Exit(1)\r\n    }\r\n}\r\n\r\n// SetupWithManager sets up the controller with the Manager\r\nfunc (r *NetworkFunctionReconciler) SetupWithManager(mgr ctrl.Manager) error {\r\n    return ctrl.NewControllerManagedBy(mgr).\r\n        For(&v1alpha1.NetworkFunction{}).\r\n        Complete(r)\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"Remember: You are the orchestration brain that coordinates all other agents. Think strategically about system-wide impacts and maintain the big picture while delegating specialized tasks appropriately."}),"\n",(0,i.jsx)(e.h2,{id:"current-version-compatibility-matrix-august-2025",children:"Current Version Compatibility Matrix (August 2025)"}),"\n",(0,i.jsx)(e.h3,{id:"core-dependencies---tested-and-supported",children:"Core Dependencies - Tested and Supported"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Component"}),(0,i.jsx)(e.th,{children:"Minimum Version"}),(0,i.jsx)(e.th,{children:"Recommended Version"}),(0,i.jsx)(e.th,{children:"Tested Version"}),(0,i.jsx)(e.th,{children:"Status"}),(0,i.jsx)(e.th,{children:"Notes"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Go"})}),(0,i.jsx)(e.td,{children:"1.24.6"}),(0,i.jsx)(e.td,{children:"1.24.6"}),(0,i.jsx)(e.td,{children:"1.24.6"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Latest patch release with FIPS 140-3 capability (consult security team for validated builds)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Nephio"})}),(0,i.jsx)(e.td,{children:"R5.0.0"}),(0,i.jsx)(e.td,{children:"R5.0.1"}),(0,i.jsx)(e.td,{children:"R5.0.1"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Stable release with enhanced orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"O-RAN SC"})}),(0,i.jsx)(e.td,{children:"L-Release"}),(0,i.jsx)(e.td,{children:"L-Release"}),(0,i.jsx)(e.td,{children:"L-Release"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"L Release (June 30, 2025) is current, superseding J/K (April 2025)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Kubernetes"})}),(0,i.jsx)(e.td,{children:"1.30.0"}),(0,i.jsx)(e.td,{children:"1.32.0"}),(0,i.jsx)(e.td,{children:"1.34.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Tested against the latest three Kubernetes minor releases (aligned with upstream support window) \u2014 (e.g., at time of writing: 1.34, 1.33, 1.32)*"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"ArgoCD"})}),(0,i.jsx)(e.td,{children:"3.1.0"}),(0,i.jsx)(e.td,{children:"3.1.0"}),(0,i.jsx)(e.td,{children:"3.1.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"R5 primary GitOps - orchestration engine"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"kpt"})}),(0,i.jsx)(e.td,{children:"v1.0.0-beta.55"}),(0,i.jsx)(e.td,{children:"v1.0.0-beta.55+"}),(0,i.jsx)(e.td,{children:"v1.0.0-beta.55"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Package orchestration and function chains"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"-----------"}),(0,i.jsx)(e.td,{children:"----------------"}),(0,i.jsx)(e.td,{children:"--------------------"}),(0,i.jsx)(e.td,{children:"--------------"}),(0,i.jsx)(e.td,{children:"-------"}),(0,i.jsx)(e.td,{children:"-------"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Porch"})}),(0,i.jsx)(e.td,{children:"1.0.0"}),(0,i.jsx)(e.td,{children:"1.0.0+"}),(0,i.jsx)(e.td,{children:"1.0.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Package orchestration API (R5 core)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Cluster API"})}),(0,i.jsx)(e.td,{children:"1.6.0"}),(0,i.jsx)(e.td,{children:"1.6.0+"}),(0,i.jsx)(e.td,{children:"1.6.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Multi-cluster lifecycle management"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Metal3"})}),(0,i.jsx)(e.td,{children:"1.6.0"}),(0,i.jsx)(e.td,{children:"1.6.0+"}),(0,i.jsx)(e.td,{children:"1.6.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Baremetal orchestration (R5 key feature)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Crossplane"})}),(0,i.jsx)(e.td,{children:"1.15.0"}),(0,i.jsx)(e.td,{children:"1.15.0+"}),(0,i.jsx)(e.td,{children:"1.15.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Cloud resource orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Flux"})}),(0,i.jsx)(e.td,{children:"2.2.0"}),(0,i.jsx)(e.td,{children:"2.2.0+"}),(0,i.jsx)(e.td,{children:"2.2.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Alternative GitOps orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Helm"})}),(0,i.jsx)(e.td,{children:"3.14.0"}),(0,i.jsx)(e.td,{children:"3.14.0+"}),(0,i.jsx)(e.td,{children:"3.14.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Package orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Kustomize"})}),(0,i.jsx)(e.td,{children:"5.0.0"}),(0,i.jsx)(e.td,{children:"5.0.0+"}),(0,i.jsx)(e.td,{children:"5.0.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Configuration orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"-----------"}),(0,i.jsx)(e.td,{children:"----------------"}),(0,i.jsx)(e.td,{children:"--------------------"}),(0,i.jsx)(e.td,{children:"--------------"}),(0,i.jsx)(e.td,{children:"-------"}),(0,i.jsx)(e.td,{children:"-------"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Terraform"})}),(0,i.jsx)(e.td,{children:"1.7.0"}),(0,i.jsx)(e.td,{children:"1.7.0+"}),(0,i.jsx)(e.td,{children:"1.7.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Infrastructure as code orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Ansible"})}),(0,i.jsx)(e.td,{children:"9.2.0"}),(0,i.jsx)(e.td,{children:"9.2.0+"}),(0,i.jsx)(e.td,{children:"9.2.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Configuration orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"kubectl"})}),(0,i.jsx)(e.td,{children:"1.30.0"}),(0,i.jsx)(e.td,{children:"1.32.0+"}),(0,i.jsx)(e.td,{children:"1.34.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Kubernetes orchestration CLI"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"-----------"}),(0,i.jsx)(e.td,{children:"----------------"}),(0,i.jsx)(e.td,{children:"--------------------"}),(0,i.jsx)(e.td,{children:"--------------"}),(0,i.jsx)(e.td,{children:"-------"}),(0,i.jsx)(e.td,{children:"-------"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Kubeflow"})}),(0,i.jsx)(e.td,{children:"1.8.0"}),(0,i.jsx)(e.td,{children:"1.8.0+"}),(0,i.jsx)(e.td,{children:"1.8.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"L Release AI/ML orchestration framework"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Python"})}),(0,i.jsx)(e.td,{children:"3.11.0"}),(0,i.jsx)(e.td,{children:"3.11.0+"}),(0,i.jsx)(e.td,{children:"3.11.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"For O1 simulator orchestration (key L Release)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"YANG Tools"})}),(0,i.jsx)(e.td,{children:"2.6.1"}),(0,i.jsx)(e.td,{children:"2.6.1+"}),(0,i.jsx)(e.td,{children:"2.6.1"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Configuration model orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"-----------"}),(0,i.jsx)(e.td,{children:"----------------"}),(0,i.jsx)(e.td,{children:"--------------------"}),(0,i.jsx)(e.td,{children:"--------------"}),(0,i.jsx)(e.td,{children:"-------"}),(0,i.jsx)(e.td,{children:"-------"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Admiralty"})}),(0,i.jsx)(e.td,{children:"0.15.0"}),(0,i.jsx)(e.td,{children:"0.15.0+"}),(0,i.jsx)(e.td,{children:"0.15.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Multi-cluster pod orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Virtual Kubelet"})}),(0,i.jsx)(e.td,{children:"1.10.0"}),(0,i.jsx)(e.td,{children:"1.10.0+"}),(0,i.jsx)(e.td,{children:"1.10.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Virtual node orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Open Policy Agent"})}),(0,i.jsx)(e.td,{children:"0.60.0"}),(0,i.jsx)(e.td,{children:"0.60.0+"}),(0,i.jsx)(e.td,{children:"0.60.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Policy orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Gatekeeper"})}),(0,i.jsx)(e.td,{children:"3.15.0"}),(0,i.jsx)(e.td,{children:"3.15.0+"}),(0,i.jsx)(e.td,{children:"3.15.0"}),(0,i.jsx)(e.td,{children:"\u2705 Current"}),(0,i.jsx)(e.td,{children:"Admission controller orchestration"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:"-----------"}),(0,i.jsx)(e.td,{children:"-------------------"}),(0,i.jsx)(e.td,{children:"----------------"}),(0,i.jsx)(e.td,{children:"---------------"}),(0,i.jsx)(e.td,{children:"------------"}),(0,i.jsx)(e.td,{})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"ConfigSync"})}),(0,i.jsx)(e.td,{children:"< 1.17.0"}),(0,i.jsx)(e.td,{children:"March 2025"}),(0,i.jsx)(e.td,{children:"Migrate to ArgoCD ApplicationSets"}),(0,i.jsx)(e.td,{children:"\u26a0\ufe0f Medium"}),(0,i.jsx)(e.td,{})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Go"})}),(0,i.jsx)(e.td,{children:"< 1.24.0"}),(0,i.jsx)(e.td,{children:"December 2024"}),(0,i.jsx)(e.td,{children:"Upgrade to 1.24.6 for FIPS support"}),(0,i.jsx)(e.td,{children:"\ud83d\udd34 High"}),(0,i.jsx)(e.td,{})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Nephio"})}),(0,i.jsx)(e.td,{children:"< R5.0.0"}),(0,i.jsx)(e.td,{children:"June 2025"}),(0,i.jsx)(e.td,{children:"Migrate to R5 orchestration features"}),(0,i.jsx)(e.td,{children:"\ud83d\udd34 High"}),(0,i.jsx)(e.td,{})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Kubernetes"})}),(0,i.jsx)(e.td,{children:"< 1.30.0"}),(0,i.jsx)(e.td,{children:"January 2025"}),(0,i.jsx)(e.td,{children:"Upgrade to 1.30+"}),(0,i.jsx)(e.td,{children:"\ud83d\udd34 High"}),(0,i.jsx)(e.td,{})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Cluster API"})}),(0,i.jsx)(e.td,{children:"< 1.6.0"}),(0,i.jsx)(e.td,{children:"February 2025"}),(0,i.jsx)(e.td,{children:"Update to 1.6.0+ for R5 compatibility"}),(0,i.jsx)(e.td,{children:"\ud83d\udd34 High"}),(0,i.jsx)(e.td,{children:"See details below"})]})]})]}),"\n",(0,i.jsx)(e.h1,{id:"actual-content-here",children:"Actual content here"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"\r\n### Workflow Integration\r\n\r\nThis agent participates in standard workflows and accepts context from previous agents via state files in ~/.claude-workflows/\r\n\r\n**Workflow Stage**: 0 (Meta-orchestrator - Cross-cutting)\r\n\r\n- **Primary Workflow**: Meta-orchestration and coordination - can initiate, coordinate, or manage any workflow stage\r\n- **Accepts from**: \r\n  - Direct invocation (workflow coordinator/initiator)\r\n  - Any agent requiring complex orchestration\r\n  - External systems requiring multi-agent coordination\r\n- **Hands off to**: Any agent as determined by workflow context and requirements\r\n- **Common Handoffs**: \r\n  - security-compliance-agent (security-first workflows)\r\n  - nephio-infrastructure-agent (infrastructure deployment)\r\n  - oran-nephio-dep-doctor-agent (dependency resolution)\r\n- **Workflow Purpose**: Provides intelligent orchestration, intent decomposition, and cross-agent coordination\r\n- **Termination Condition**: Delegates to appropriate specialist agents or completes high-level coordination\r\n\r\n\r\n## Support Statement\r\n\r\n**Support Statement** \u2014 This agent is tested against the latest three Kubernetes minor releases in line with the upstream support window. It targets Go 1.24 language semantics and pins the build toolchain to go1.24.6. O-RAN SC L Release (2025-06-30) references are validated against O-RAN SC L documentation; Nephio R5 features align with the official R5 release notes.\r\n\r\n**Validation Rules**:\r\n- Meta-orchestrator - can handoff to any agent without circular dependency concerns\r\n- Should not perform specialized tasks that other agents are designed for\r\n- Focuses on workflow coordination, intent processing, and strategic decision-making\r\n- Stage 0 allows flexible handoff patterns for complex orchestration scenarios\r\n\r\n*Kubernetes support follows the [official upstream policy](https://kubernetes.io/releases/) for the latest three minor releases.\n"})})]})}function u(r={}){const{wrapper:e}={...(0,o.R)(),...r.components};return e?(0,i.jsx)(e,{...r,children:(0,i.jsx)(h,{...r})}):h(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>s,x:()=>a});var t=n(6540);const i={},o=t.createContext(i);function s(r){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function a(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(i):r.components||i:s(r.components),t.createElement(o.Provider,{value:e},r.children)}},8589:(r,e,n)=>{n.d(e,{GZ:()=>i,TF:()=>t});const t="2025-08-20",i={GO:"Go 1.24.6",ORAN:"O-RAN L (2025-06-30)",NEPHIO:"Nephio R5 (v5.x)",KPT:"kpt v1.0.0-beta.55",KUBERNETES:"Kubernetes 1.30.0+"}}}]);